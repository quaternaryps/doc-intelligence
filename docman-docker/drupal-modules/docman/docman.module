<?php
// TODO: Folderize documents

// TODO: Advanced search features

// TODO: Fix sorting problem
// TODO: Support for date sorting

// TODO: Use database to determine what fields are required

// TODO: Allow creation of new (custom) fields
// TODO: For 'other' doc types, allow specifying required fields

// TODO: Case management features

// TODO: Add autocomplete to search filter

// TODO: Support detecting duplicate/update

function docman_entity_info() {
  return array(
    'docman' => array(
      'label' => 'Managed Document',
      'plural label' => 'Managed Documents',
      'description' => 'An entity to house managed documents and metadata',
      'controller class' => 'DocmanController',
      'base table' => 'docman',
      'revision table' => 'docman_revision',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'pid',
        'revision' => 'vid',
      ),
      'uri callback' => 'docman_uri',
      'static cache' => TRUE,
      'bundles' => array(
        'docman' => array(
          'label' => 'Docman',
          'admin' => array(
            'path' => 'admin/structure/docman/manage',
            'access arguments' => array('administer docman entities'),
          ),
        ),
      ),
      'view modes' => array(
        'full' => array(
          'label' => 'Full Docman',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );
}

function docman_uri($docman) {
  return array('path' => 'docman/' . $docman->pid);
}

function docman_menu() {
  return array(
    'home' => array(
      'title' => 'Home',
      'page callback' => 'home_page',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
    ),
    'upload' => array(
      'title' => 'Upload',
      'description' => 'Upload a document',
      'page callback' => 'validate_login_upload',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
      'file' => 'upload.inc',
    ),
    // 'browse' => array(
      // 'title' => 'Search',
      // 'description' => 'Browse documents',
      // 'page callback' => 'validate_login_browse',
      // 'access callback' => TRUE,
      // 'type' => MENU_CALLBACK,
      // 'file' => 'browse.inc',
    // ),
    'policy' => array(
      'title' => 'Policy View',
      'description' => 'Browse documents by policy number',
      'page callback' => 'validate_login_policy',
      'page arguments' => array(1),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
      'file' => 'policy.inc',
    ),
    'search' => array(
      'title' => 'Search',
      'description' => 'Search for documents',
      'page callback' => 'validate_login_search',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
      'file' => 'search.inc',
    ),
    'docman/%docman' => array(
      'title' => 'Document',
      'description' => 'View a document\'s details',
      'page callback' => 'validate_login_view',
      'page arguments' => array(1),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
      'file' => 'view.inc',
    ),
    'flip/%docman' => array(
      'page callback' => 'thumb_flip_callback',
      'page arguments' => array(1),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
      'file' => 'view.inc',
    ),
    'email/%docman' => array(
      'page callback' => 'email_callback',
      'page arguments' => array(1),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
      'file' => 'view.inc',
    ),
    'fax/%docman' => array(
      'page callback' => 'fax_callback',
      'page arguments' => array(1),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
      'file' => 'view.inc',
    ),
    'docman/migrate' => array(
      'title' => 'Migrate From Zoho',
      'page callback' => 'docman_migrate',
      'access arguments' => array('administer docman entities'),
      'file' => 'migrate.inc',
    ),
    'admin/structure/docman/manage' => array(
      'title' => 'Docman Admin',
      'description' => 'Manage Docman Entities Structure',
      'page callback' => 'docman_admin_page',
      'access arguments' => array('administer docman entities'),
    ),
    'docman/backup' => array(
      'title' => 'Backup DMS before uninstall (does not replace proper backup)',
      'page callback' => 'docman_backup',
      'access arguments' => array('administer docman entities'),
    ),
    'docman/restore' => array(
      'title' => 'Restore DMS from previous install',
      'page callback' => 'docman_restore',
      'access arguments' => array('administer docman entities'),
    ),
    'docman/clear' => array(
      'title' => 'Clear DMS-related fields before uninstall',
      'page callback' => 'docman_clear',
      'access arguments' => array('administer docman entities'),
    ),
    'autocomplete/%' => array(
      'page callback' => 'autocomplete',
      'page arguments' => array(1),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
    ),
  );
}

function home_page() {
//  drupal_add_js(drupal_get_path('module', 'docman') . '/iframeUpdateSend.js');
  return array(
    '#markup' => '
      <p>Welcome to Ethio-American Insurance\'s Document Management System!</p>
      <p>Please report any errors or suggestions to <a href="mailto:berukez@ethio-american.com">Beruke</a>.</p>
    '
  );
}

function docman_permissions() {
  return array(
    'administer docman entities' => array(
      'title' => 'Administer Docman Entities',
      'restrict access' => TRUE,
    ),
/*    'view docman entities' => array(
        'title' => 'View Docman Entities'),
    'create docman entities' => array(
        'title' => 'Create Docman Entities'),*/
  );
}

function docman_admin_page() {
  return 'Welcome to the Docman administration page<br/>' .
    '<br /><b> Be careful when selecting an option!</b><br /><br />' .
    '<a href="/docman/migrate">Zoho import</a><br />' .
    '<a href="/docman/backup">Backup (use before uninstall)</a><br />' .
    '<a href="/docman/restore">Restore (use after reinstall)</a><br />' .
    '<a href="/docman/clear">Clear (use before uninstall)</a>';
}

function docman_backup() {
  $tables = array('docman', 'docman_revision');

  foreach ($tables as $table) {
    $backup_table = $table . '_backup';

    $entities = db_query('SELECT * FROM {' . $table . '}')->fetchAll();

    db_drop_table($backup_table);
    db_create_table($backup_table, drupal_get_schema($table));

    foreach ($entities as $entity) {
      db_insert($backup_table)->fields((array) $entity)->execute();
    }
  }

  return 'Backup complete';
}

function docman_restore() {
  $tables = array('docman', 'docman_revision');

  foreach ($tables as $table) {
    $backup_table = $table . '_backup';

    $entities = db_query('SELECT * FROM {' . $backup_table . '}')->fetchAll();

    db_drop_table($table);
    db_create_table($table, drupal_get_schema($table));

    foreach ($entities as $entity) {
      db_insert($table)->fields((array) $entity)->execute();
    }
  }

  return 'Restore complete';
}

function get_thumb_url($doc) {
  $is_image =
    str_ends_with($doc['uri'], '.jpg')  ||
    str_ends_with($doc['uri'], '.jpeg') ||
    str_ends_with($doc['uri'], '.png') ||
    str_ends_with($doc['uri'], '.bmp');

  $thumb_uri = $is_image ? $doc['uri'] :
    'public://Thumbnails/' . $doc['fid'] . '.png';

  if (!file_exists($thumb_uri)) {
    $do_thumb =
      str_ends_with($doc['uri'], '.pdf')  ||
      str_ends_with($doc['uri'], '.txt')  ||
      str_ends_with($doc['uri'], '.tif')  ||
      str_ends_with($doc['uri'], '.tiff');

    if ($do_thumb) {
      try {
        $im = new Imagick(drupal_realpath($doc['uri']) . '[0]');
        $im->setImageFormat('png');
        $im->writeImage(drupal_realpath($thumb_uri));
      }
      catch (Exception $e) {
        $thumb_uri = 'public://Thumbnails/deadbeef.png';
      }
    } else {
      $thumb_uri = 'public://Thumbnails/deadbeef.png';
    }
  }

  return file_create_url($thumb_uri);
}

function docman_clear() {
  $fields = field_info_instances('docman', 'docman');

  foreach ($fields as $field => $data) {
    $table = 'field_data_' . $field;
    $table_revision = 'field_revision_' . $field;
    db_delete($table)->execute();
    db_delete($table_revision)->execute();
  }

  return 'Clear complete';
}

function autocomplete($field, $string) {
  if (isset($field)) {
    $table = 'field_data_' . $field;
    $value = $field . '_value';
  }

  $matches = array();

  $results = db_select($table, 'c')
    ->fields('c', array($value))
    ->condition($value, '%' . db_like($string) . '%', 'LIKE')
    ->range(0, 10)
    ->execute();

  foreach ($results as $row) {
    $matches[$row->$value] = check_plain($row->$value);
  }

  drupal_json_output($matches);
}

function str_begins_with($haystack, $needle) {
  return substr($haystack, 0, strlen($needle)) == $needle;
}

#function str_ends_with($haystack, $needle) {
#  return substr($haystack, -strlen($needle)) == $needle;
#}

if (!function_exists('str_ends_with')) {
    function str_ends_with($haystack, $needle) {
        $length = strlen($needle);
        if ($length == 0) {
            return true;
        }
        return (substr($haystack, -$length) === $needle);
    }
}

function get_username($id) {
  return db_query('SELECT name FROM {users} WHERE uid = ' . $id)->fetchField();
}

function docman_save(&$docman) {
  return entity_get_controller('docman')->save($docman);
}

function docman_load_multiple($pids = array(), $reset = FALSE) {
  return entity_load('docman', $pids, $reset);
}

function docman_load($pid = NULL, $reset = FALSE) {
  $pids = isset($pid) ? array($pid) : array();
  $docs = docman_load_multiple($pids, $reset);

  return $docs ? reset($docs) : FALSE;
}

class DocmanController extends DrupalDefaultEntityController {
  public function save($entity) {
    $entity = (object) $entity;
     // Determine if we will be inserting a new entity.
    $entity->is_new = !(isset($entity->pid) && is_numeric($entity->pid));

    $transaction = db_transaction();

    // Set the timestamp fields.
    if (empty($entity->created)) {
      $entity->created = REQUEST_TIME;
    }

    // Only change revision timestamp if it doesn't exist.
    if (empty($entity->timestamp)) {
      $entity->timestamp = REQUEST_TIME;
    }

    $entity->changed = REQUEST_TIME;

    field_attach_presave('docman', $entity);
    module_invoke_all('entity_presave', $entity, 'docman');

    // When saving a new entity revision, unset any existing $entity->vid
    // to ensure a new revision will actually be created and store the old
    // revision ID in a separate property for entity hook implementations.
    if (!$entity->is_new && !empty($entity->revision) && $entity->vid) {
      $entity->old_vid = $entity->vid;
      unset($entity->vid);
      $entity->timestamp = REQUEST_TIME;
    }

    module_invoke_all('entity_presave', $entity, 'docman');

    try {
      if (!$entity->is_new) {
        // Since we already have an pid, write the revision to ensure the
        // vid is the most up to date, then write the record.
        $this->saveRevision($entity);
        drupal_write_record('docman', $entity, 'pid');

        field_attach_update('docman', $entity);
        module_invoke_all('entity_update', $entity, 'docman');

      }
      else {
        // If this is new, write the record first so we have an pid,
        // then save the revision so that we have a vid. This means we
        // then have to write the vid again.
        drupal_write_record('docman', $entity);
        $this->saveRevision($entity);
        db_update('docman')
          ->fields(array('vid' => $entity->vid))
          ->condition('pid', $entity->pid)
          ->execute();

        field_attach_insert('docman', $entity);
        module_invoke_all('entity_insert', $entity, 'docman');
      }

      return $entity;
    }
    catch (Exception $e) {
      $transaction->rollback('docman');
      watchdog_exception('docman', $e);
    }

    return FALSE;
  }

  function saveRevision($entity, $uid = NULL) {
    if (!isset($uid)) {
      $uid = $GLOBALS['user']->uid;
    }

    $entity->uid = $uid;
    // Update the existing revision if specified.
    if (!empty($entity->vid)) {
      drupal_write_record('docman_revision', $entity, 'vid');
    }
    else {
      // Otherwise insert a new revision. This will automatically update $entity
      // to include the vid.
      drupal_write_record('docman_revision', $entity);
    }
  }

/*  public function attachLoad(&$queried_entities, $revision_id = FALSE) {
    parent::attachLoad($queried_entities, $revision_id);
    return;

    // We need to go through and unserialize our serialized fields.
    foreach ($queried_entities as $entity) {
      foreach (array('view_access', 'edit_access') as $key) {
        if (is_string($entity->$key)) {
          $entity->$key = unserialize($entity->$key);
        }
      }
    }
  }

  public function buildQuery($ids, $conditions = array(), $revision_id = FALSE) {
    return parent::buildQuery($ids, $conditions, $revision_id);
    // Add an alias to this query to ensure that we can tell if this is
    // the current revision or not.
    $query = parent::buildQuery($ids, $conditions, $revision_id);
    $query->addField('base', 'vid', 'current_vid');

    return $query;
  }

  public function access($op, $entity = NULL, $account = NULL) {
    return TRUE;
    if ($op !== 'create' && !$entity) {
      return FALSE;
    }

    // The administer permission is a blanket override.
    if (user_access('administer fieldable panels panes')) {
      return TRUE;
    }

    switch ($op) {
      case 'create':
        return user_access('create fieldable ' . $entity);

      case 'view':
        ctools_include('context');
        return ctools_access($entity->view_access, fieldable_panels_panes_get_base_context($entity));

      case 'update':
        ctools_include('context');
        return user_access('edit fieldable ' . $entity->bundle) && ctools_access($entity->edit_access, fieldable_panels_panes_get_base_context($entity));

      case 'delete':
        ctools_include('context');
        return user_access('delete fieldable ' . $entity->bundle) && ctools_access($entity->edit_access, fieldable_panels_panes_get_base_context($entity));

    }

    return FALSE;
  }

  public function view($entity, $view_mode = 'full', $langcode = NULL) {
    // attach our fields and prepare the pane for rendering
    field_attach_prepare_view('docman', array($entity->pid => $entity), $view_mode, $langcode);
    entity_prepare_view('docman', array($entity->pid => $entity), $langcode);
    $entity->content = field_attach_view('docman', $entity, $view_mode, $langcode);
    $entity->content += array(
      '#docman' => $entity,
      '#theme' => 'docman',
      '#element' => $entity,
      '#view_mode' => $view_mode,
      '#language' => $langcode,
    );

    $entity_type = 'docman';
    drupal_alter(array('docman_view', 'entity_view'), $entity->content, $entity_type);

    return $entity->content;
  }

  public function delete($pids) {
    return;
    $transaction = db_transaction();
    if (!empty($pids)) {
      $entities = fieldable_panels_panes_load_multiple($pids, array());

      try {
        foreach ($entities as $pid => $entity) {
          // Call the entity-specific callback (if any):
          module_invoke_all('entity_delete', $entity, 'docman');
          field_attach_delete('docman', $entity);
        }

        // Delete after calling hooks so that they can query entity tables as needed.
        db_delete('docman')
          ->condition('pid', $pids, 'IN')
          ->execute();

        db_delete('fieldable_panels_panes_revision')
          ->condition('pid', $pids, 'IN')
          ->execute();
      }
      catch (Exception $e) {
        $transaction->rollback();
        watchdog_exception('docman', $e);
        throw $e;
      }

      // Clear the page and block and entity_load_multiple caches.
      entity_get_controller('docman')->resetCache();
    }
  }

  public function create($values) {
    $entity = (object) array(
      'bundle' => $values['bundle'],
      'language' => LANGUAGE_NONE,
      'is_new' => TRUE,
    );

    // Ensure basic fields are defined.
    $values += array(
      'bundle' => 'docman',
      'title' => '',
      'link' => '',
      'path' => '',
      'reusable' => FALSE,
      'admin_title' => '',
      'admin_description' => '',
      'category' => '',
      'vid' => '',
      'current_vid' => '',
    );

    // Apply the given values.
    foreach ($values as $key => $value) {
      $entity->$key = $value;
    }

    return $entity;
  }*/
}

?>

